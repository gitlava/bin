#!/usr/bin/ruby

require 'yaml'
require 'openssl'
require 'net/http'
require 'date'
require 'optparse'
require 'ostruct'
require 'base64'
require 'pp'


class BBBHelper
  SECONDS_IN_8H = 28800

  MSG_ETA_PLANNED   = "Запланировано:"
  MSG_ETA_ACTUAL    = "Отработано:"
  MSG_ETA_OVERTIME  = "Переработано:"
  MSG_ETA_REMAINING = "Недоработано:"
  MSG_ETA_FINISHED  = "Отработка была в:"
  MSG_ETA_FINISH    = "Отработка в:"

  MSG_HOURS_HOLIDAY       = "Выходной"
  MSG_HOURS_DAY_OFF       = "Отгул"
  MSG_HOURS_VACATION      = "Отпуск"
  MSG_HOURS_UNPAID_LEAVE  = "ОЗС"
  MSG_HOURS_SICK_LEAVE    = "Больничный"
  MSG_HOURS_BUSINESS_TRIP = "Командировка"
  MSG_HOURS_NO_CONTROL    = "Снят контроль"

  def self.debug?
    @debug ||= false
  end

  def self.debug=(value)
    @debug = value
  end

  def self.debug_http_get_headers(request)
    return unless debug?

    STDERR.puts 'GET Request:'
    STDERR.puts request.path
    request.each_header {|key,value| STDERR.puts "| #{key} = #{value}"}
  end

  def self.debug_http_response_headers(response)
    return unless debug?

    STDERR.puts 'Response:'
    STDERR.puts response.inspect
    response.header.each_header {|key,value| STDERR.puts "| #{key} = #{value}"}
  end

  def self.http_extract_cookies(response)
    all_cookies = response.get_fields('set-cookie')
    unless all_cookies == nil
      cookies_array = Array.new
      all_cookies.each {|cookie| cookies_array.push(cookie.split('; ')[0])}
      $cookies = cookies_array.join('; ')
    end
  rescue
    raise 'Cookies not extracted for an unknown reason.'
  end

  def self.p_debug(lines)
    if debug?
      lines.split("\n").each do |line|
        STDERR.puts "D,#{line}"
      end
    end
  end

  def self.p_warning(lines)
    lines.split("\n").each do |line|
      STDERR.puts "W,#{line}"
    end
  end

  def self.p_error(lines)
    lines.split("\n").each do |line|
      STDERR.puts "E,#{line}"
    end
  end

  def self.cwb(date = Date.today)
    date - date.wday + 1
  end

  def self.cwe(date = Date.today)
    date - date.wday + 7
  end

  def self.timestr_to_seconds(str)
    timearr = str.split(':').map {|s| s.to_i}
    timearr[0]*3600 + timearr[1]*60 + timearr[2]
  end

  def self.seconds_to_timestr(n)
    n = n.abs

    hours = n / 3600
    r = n % 3600
    minutes = r / 60
    seconds = r % 60

    sprintf("%02d:%02d:%02d", hours, minutes, seconds)
  end

  def self.out_of_office(params)
    return MSG_HOURS_BUSINESS_TRIP if params[:business_trip]
    return MSG_HOURS_HOLIDAY if params[:holiday]
    return MSG_HOURS_SICK_LEAVE if params[:sick_leave]
    return MSG_HOURS_UNPAID_LEAVE if params[:unpaid_leave]
    return MSG_HOURS_DAY_OFF if params[:day_off]
    return MSG_HOURS_VACATION if params[:vacation]
    return MSG_HOURS_NO_CONTROL if params[:no_control]
    return ""
  end

  def self.formatted_printout(format, data)
    if data.nil?
      puts 'No data found'
      exit 0
    end

    puts "#{data[:name]} (#{data[:id]})"

    case format
    when BBBOptions::CMD_HOURS
      l = find_max_length([MSG_HOURS_HOLIDAY,
                           MSG_HOURS_DAY_OFF,
                           MSG_HOURS_VACATION,
                           MSG_HOURS_UNPAID_LEAVE,
                           MSG_HOURS_SICK_LEAVE,
                           MSG_HOURS_BUSINESS_TRIP,
                           MSG_HOURS_NO_CONTROL])

      data[:hours].each do |h|
        printf("%10s  %8s  %4.2f  %-#{l}s  %s\n",
               h[:date],
               h[:hours],
               h[:rate],
               out_of_office(h),
               h[:comments].join('/'))
      end
    when BBBOptions::CMD_ETA
      l = find_max_length([MSG_ETA_PLANNED,
                           MSG_ETA_ACTUAL,
                           MSG_ETA_OVERTIME,
                           MSG_ETA_REMAINING,
                           MSG_ETA_FINISHED,
                           MSG_ETA_FINISH])
      printf("%-#{l}s %11s\n", MSG_ETA_PLANNED, seconds_to_timestr(data[:eta][:planned]))
      printf("%-#{l}s %11s\n", MSG_ETA_ACTUAL, seconds_to_timestr(data[:eta][:actual]))
      if data[:eta][:remaining] < 0
        printf("%-#{l}s %11s\n", MSG_ETA_OVERTIME, seconds_to_timestr(data[:eta][:remaining]))
        printf("%-#{l}s %11s\n", MSG_ETA_FINISHED, seconds_to_timestr(data[:eta][:finish])) if data[:eta][:finish]
      else
        printf("%-#{l}s %11s\n", MSG_ETA_REMAINING, seconds_to_timestr(data[:eta][:remaining]))
        printf("%-#{l}s %11s\n", MSG_ETA_FINISH, seconds_to_timestr(data[:eta][:finish])) if data[:eta][:finish]
      end
    end
  end

  def self.find_max_length(lines)
    lines.map{|l| l.length}.max
  end
end


class BBBrute
  SESSION_FILE = File.join(Dir.home, '.bbbrute/cookies.b64')

  module STAT
    LATENESS  =  0
    ABSENCE   =  1
    TIMES     =  2
    DOORS     =  3
  end

  LOGIN_PAGE = 'misc/login.asp'
  DOORS_PAGE = 'Door/DoorPers.asp'
  EMPL_PAGE  = 'List/NetEmpl.asp'
  USERAGENT  = 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.1'

  def initialize(options)
    @options = options

    uri = URI(@options.server)

    @http = Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == 'https', verify_mode: OpenSSL::SSL::VERIFY_NONE)
  end

  def build_query(stat, params)
    id = params[:id]
    bdate = params[:bdate]
    edate = params[:edate]
    query = 'Bt=%CF%EE%E8%F1%EA&Period=0'
    query += "&RG=#{stat}"
    query += "&Empl=#{id}" if id
    query += "&bD=#{bdate.day}&bMn=#{bdate.month}&bYr=#{bdate.year}"
    query += "&eD=#{edate.day}&eMn=#{edate.month}&eYr=#{edate.year}"
  end

  def auth
    load_session
    if test_connection_response != '200'
      BBBHelper::p_warning "Session expired. Logging in..."

      uri = URI.join(@options.server, LOGIN_PAGE)
      request = Net::HTTP::Get.new(uri.request_uri, {'user-agent' => USERAGENT})
      request.basic_auth(@options.login, @options.password)
      response = @http.request(request)

      BBBHelper::debug_http_get_headers(request)
      BBBHelper::debug_http_response_headers(response)

      raise 'Authorization failed (401)' if response.code == '401'

      $cookies = BBBHelper::http_extract_cookies(response)
      save_session
    end
  end

  def test_connection_response
    uri = URI.join(@options.server + '/' + EMPL_PAGE)

    request = Net::HTTP::Get.new(uri.request_uri, {'user-agent' => USERAGENT})
    request.basic_auth(@options.login, @options.password)
    request.add_field('cookie', $cookies)
    response = @http.request(request)
    response.code
  end

  def load_session
    f = File.read(SESSION_FILE)
    $cookies = Base64.decode64(f)
    BBBHelper.p_debug 'Session restored from the file: ' + SESSION_FILE
  rescue
    BBBHelper.p_debug 'Unable to restore session from the file: ' + SESSION_FILE
  end

  def save_session
    Dir.mkdir(File.dirname(SESSION_FILE)) unless Dir.exist?(File.dirname(SESSION_FILE))
    File.open(SESSION_FILE, mode = 'w') {|f| f.puts(Base64.encode64($cookies))}
  rescue
    BBBHelper.p_warning "Unable to save session to the file(#{SESSION_FILE})"
  end

  def execute(command, params = {})
    BBBHelper.p_debug 'Parsed command: ' + command.to_s

    case command.instruction
    when BBBOptions::CMD_HOURS
      data = doors(command)
      BBBHelper::formatted_printout(BBBOptions::CMD_HOURS, data)
    when BBBOptions::CMD_ETA
      data = doors(command, {fill_eta: true})
      BBBHelper::formatted_printout(BBBOptions::CMD_ETA, data)
    when BBBOptions::CMD_LOCATE
      puts 'Placeholder command: ' + command.instruction.to_s
    when BBBOptions::CMD_FIRST
      puts 'Placeholder command: ' + command.instruction.to_s
    when BBBOptions::CMD_LAST
      puts 'Placeholder command: ' + command.instruction.to_s
    when BBBOptions::CMD_QUERY
      if params[:query_mode]
        puts 'Unable to execute while in query mode.'
      else
        printf "Enter 'exit' to quit.\n> "
        while input = gets
          begin
          input_argv = input.chomp.split(/\s/)
          query_command = @options.parse_command(input_argv)
          execute(query_command, {query_mode: true})
          printf '> '
          rescue => exception
            BBBHelper::p_error exception.to_s
          end
        end
      end
    when BBBOptions::CMD_SAVE
      @options.save_config
    when BBBOptions::CMD_EXIT
      if params[:query_mode]
        exit 0
      else
        puts 'Unrecognized command: ' + command.instruction.to_s
        exit 1
      end
    else
      puts 'Unrecognized command: ' + command.instruction.to_s
      exit 1 unless params[:query_mode]
    end
  end

  def doors(command, params = {})
    uri = URI.join(@options.server + '/' + DOORS_PAGE + '?' + build_query(STAT::TIMES, {
      :id => command.args.id,
      :bdate => command.args.from,
      :edate => command.args.to}))

    request = Net::HTTP::Get.new(uri.request_uri, {'user-agent' => USERAGENT})
    request.basic_auth(@options.login, @options.password)
    request.add_field('cookie', $cookies)
    response = @http.request(request)

    BBBHelper::debug_http_get_headers(request)
    BBBHelper::debug_http_response_headers(response)

    BBBHelper::p_debug "#{command.args.id} #{response.inspect}"

    body = response.body.force_encoding('CP1251').encode('UTF-8')

    # BBBHelper::p_debug 'BODY'
    # BBBHelper::p_debug body
    # BBBHelper::p_debug 'END BODY'

    parsed_data = nil

    if body_dissect = body.match(/<TR><TD ALIGN=Right rowspan=(\d+)>1.<TD rowspan=\d+><a href=\.\.\/misc\/PersInfo\.asp\?ID=(\d+)>(.*?)<\/a><\/td>(.*)<\/tr><TR><TD ALIGN=Left bgcolor = Silver>/)

      parsed_data= {}
      parsed_data[:count] = body_dissect.captures[0].to_i - 1
      BBBHelper.p_debug "#    = " + parsed_data[:count].to_s

      parsed_data[:id] = body_dissect.captures[1].to_i
      BBBHelper.p_debug "Id   = " + parsed_data[:id].to_s

      parsed_data[:name] = body_dissect.captures[2]
      BBBHelper.p_debug "Name = " + parsed_data[:name]

      rawdata = body_dissect.captures[3]
      BBBHelper.p_debug "Data = #{rawdata.length}B"

      parsed_data[:hours] = rawdata.split('<tr>').map do |line|
        hours_data = {
          holiday:        false,
          date:           nil,
          hours:          nil,
          rate:           nil,
          day_off:        nil,
          vacation:       nil,
          unpaid_leave:   nil,
          sick_leave:     nil,
          business_trip:  nil,
          no_control:     nil,
          comments:       []
        }

        if h = line.scan(/<TD.*?>(.*?)<\/TD>/)
          hours_data[:holiday] = true if h[0][0].match(/Red/)
          hours_data[:date]           = h[0][0].gsub(/[^0-9.]+/, '')
          hours_data[:hours]          = h[1][0].gsub(/[^0-9:]+/, '')
          hours_data[:rate]           = h[2][0].sub(',', '.').to_f
          [
            {index: 3, atom: :day_off},
            {index: 4, atom: :vacation},
            {index: 5, atom: :unpaid_leave},
            {index: 6, atom: :sick_leave},
            {index: 7, atom: :business_trip},
            {index: 8, atom: :no_control}
          ].each do |field|
            if h[field[:index]][0] != '&nbsp'
              hours_data[field[:atom]] = true
              if c = h[field[:index]][0].match(/ALT = "(.*?)"/)
                hours_data[:comments] << c.captures[0]
              end
            end
          end
        end

        hours_data
      end
    end

    parsed_data = fill_eta(command, parsed_data) if params[:fill_eta]
    parsed_data
  end

  def fill_eta(command, data)
    data[:eta] = data[:hours].map do |h|
      if h[:holiday] or h[:day_off] or h[:vacation] or
        h[:unpaid_leave] or h[:sick_leave] or
        h[:business_trip] or h[:no_control]
        {date: h[:date], planned: 0, actual: 0}
      else
        planned_load = (h[:rate]*BBBHelper::SECONDS_IN_8H).round
        actual = BBBHelper.timestr_to_seconds(h[:hours])

        {
          date: h[:date],
          planned: planned_load,
          actual: actual
        }
      end
    end.reduce do |h1, h2|
      {planned: h1[:planned] + h2[:planned], actual: h1[:actual] + h2[:actual]}
    end

    data[:eta][:remaining] = data[:eta][:planned] - data[:eta][:actual]
    if command.args.to >= Date.today
      data[:eta][:finish] = Time.now.to_i - Date.today.to_time.to_i + data[:eta][:remaining]
    end
    data
  end
end


class BBBOptions
  CONFIG_FILE = File.join(Dir.home, '.bbbrute/config.yml')

  CMD_GLOBAL      = ''
  CMD_HOURS       = 'hours'
  CMD_ETA         = 'eta'
  CMD_LOCATE      = 'locate'
  CMD_FIRST       = 'first'
  CMD_LAST        = 'last'
  CMD_QUERY       = 'query'
  CMD_SAVE        = 'save'
  CMD_EXIT        = 'exit'

  MSG_USAGE                   = 'Usage: %s [OPTIONS...] COMMAND [ARGS...]'
  MSG_DESCRIPTION             = 'BBBrute exists to help you with the analysis of timesheets'
  MSG_COMMAND_PRINTOUT        = '%s (%s)'
  MSG_SEPARATOR_OPTIONS       = 'OPTIONS'
  MSG_SEPARATOR_COMMANDS      = 'COMMANDS'
  MSG_DESCRIPTION_HOURS       = 'Print hours worked by person during a selected period'
  MSG_DESCRIPTION_ETA         = 'Calculated remaining workload for a selected period'
  MSG_DESCRIPTION_LOCATE      = 'Find out, where is person now, looking by the last entry'
  MSG_DESCRIPTION_FIRST       = 'List all first entries during a selected period'
  MSG_DESCRIPTION_LAST        = 'List all last entries during a selected period'
  MSG_DESCRIPTION_QUERY       = 'Interactive mode. Usage: COMMAND [ARGS...]'
  MSG_DESCRIPTION_SAVE        = 'Save entered global options for future use'
  MSG_OPTION_HELP             = 'Show help message'
  MSG_OPTION_DEBUG            = 'Print debug information'
  MSG_OPTION_SERVER           = 'Address of the timesheets server (example: https://example.org)'
  MSG_OPTION_LOGIN            = 'Domain login of the user with access to the timesheets server'
  MSG_OPTION_PASSWORD         = 'Password of the user with access to the timesheets server'
  MSG_OPTION_MACHINE          = 'Output data as a JSON for further processing'
  MSG_ARGUMENT_ID             = 'ID of the person to check timesheet for (default: logged user)'
  MSG_ARGUMENT_FROM           = 'Beginning of the date range to check (default: today)'
  MSG_ARGUMENT_TO             = 'End of the date range to check (default: equals from)'
  MSG_ARGUMENT_WEEK           = 'Calculate full week which includes FROM value'

  def initialize
    @options = OpenStruct.new
    @options.debug            = false
    @options.server           = nil
    @options.login            = nil
    @options.password         = nil
    @options.machine_friendly = false

    @session = OpenStruct.new
    @session.config = nil

    load_config
    load_session
    setup_parsers
  end

  def method_missing(method, *args, &block)
    @options.send(method, *args, &block)
  end

  def exec_help_printout
    @parsers.each do |parser_name, parser_scheme|
      puts parser_scheme
    end

    exit 0
  end

  def setup_parsers
    @parsers = {
      CMD_GLOBAL => OptionParser.new do |o|
        o.banner = MSG_USAGE % File.basename($0)
        o.separator MSG_DESCRIPTION
        o.separator ''
        o.separator MSG_SEPARATOR_OPTIONS

        o.on('-h', '--help', MSG_OPTION_HELP)\
          { exec_help_printout }

        o.on('-d', '--[no-]debug', MSG_OPTION_DEBUG)\
          {|b| @options.debug = b}

        o.on('-s', '--server HOSTNAME', String, MSG_OPTION_SERVER)\
          {|s| @options.server = s}

        o.on('-l', '--login LOGIN', String, MSG_OPTION_LOGIN)\
          {|s| @options.login = s}

        o.on('-p', '--password PASSWORD', String, MSG_OPTION_PASSWORD)\
          {|s| @options.password = s}

        o.on('-m', '--[no-]machine-friendly', MSG_OPTION_MACHINE)\
          {|b| @options.machine_friendly = b}

        o.separator ''
        o.separator MSG_SEPARATOR_COMMANDS
      end,

      CMD_HOURS => OptionParser.new do |o|
        o.banner = MSG_COMMAND_PRINTOUT % [CMD_HOURS, MSG_DESCRIPTION_HOURS]

        o.on('-i', '--id ID', Integer, MSG_ARGUMENT_ID)\
          {|i| @command.args.id = i}

        o.on('-f', '--from DD.MM.YYYY', String, MSG_ARGUMENT_FROM)\
          {|s| @command.args.from = Date.parse(s)}

        o.on('-t', '--to DD.MM.YYYY', String, MSG_ARGUMENT_TO)\
          {|s| @command.args.to = Date.parse(s)}

        o.on('-w', '--[no-]week', MSG_ARGUMENT_WEEK)\
          {|b| @command.args.week = b}

        o.separator ''
      end,

      CMD_ETA => OptionParser.new do |o|
        o.banner = MSG_COMMAND_PRINTOUT % [CMD_ETA, MSG_DESCRIPTION_ETA]

        o.on('-i', '--id ID', Integer, MSG_ARGUMENT_ID)\
          {|i| @command.args.id = i}

        o.on('-f', '--from DD.MM.YYYY', String, MSG_ARGUMENT_FROM)\
          {|s| @command.args.from = Date.parse(s)}

        o.on('-t', '--to DD.MM.YYYY', String, MSG_ARGUMENT_TO)\
          {|s| @command.args.to = Date.parse(s)}

        o.on('-w', '--[no-]week', MSG_ARGUMENT_WEEK)\
          {|b| @command.args.week = b}

        o.separator ''
      end,

      CMD_LOCATE => OptionParser.new do |o|
        o.banner = MSG_COMMAND_PRINTOUT % [CMD_LOCATE, MSG_DESCRIPTION_LOCATE]

        o.on('-i', '--id ID', Integer, MSG_ARGUMENT_ID)\
          {|i| @command.args.id = i}

        o.separator ''
      end,

      CMD_FIRST => OptionParser.new do |o|
        o.banner = MSG_COMMAND_PRINTOUT % [CMD_FIRST, MSG_DESCRIPTION_FIRST]

        o.on('-i', '--id ID', Integer, MSG_ARGUMENT_ID)\
          {|i| @command.args.id = i}

        o.on('-f', '--from DD.MM.YYYY', String, MSG_ARGUMENT_FROM)\
          {|s| @command.args.from = Date.parse(s)}

        o.on('-t', '--to DD.MM.YYYY', String, MSG_ARGUMENT_TO)\
          {|s| @command.args.to = Date.parse(s)}

        o.separator ''
      end,

      CMD_LAST => OptionParser.new do |o|
        o.banner = MSG_COMMAND_PRINTOUT % [CMD_LAST, MSG_DESCRIPTION_LAST]

        o.on('-i', '--id ID', Integer, MSG_ARGUMENT_ID)\
          {|i| @command.args.id = i}

        o.on('-f', '--from DD.MM.YYYY', String, MSG_ARGUMENT_FROM)\
          {|s| @command.args.from = Date.parse(s)}

        o.on('-t', '--to DD.MM.YYYY', String, MSG_ARGUMENT_TO)\
          {|s| @command.args.to = Date.parse(s)}

        o.separator ''
      end,

      CMD_QUERY => OptionParser.new do |o|
        o.banner = MSG_COMMAND_PRINTOUT % [CMD_QUERY, MSG_DESCRIPTION_QUERY]
        o.separator ''
      end,

      CMD_SAVE => OptionParser.new do |o|
        o.banner = MSG_COMMAND_PRINTOUT % [CMD_SAVE, MSG_DESCRIPTION_SAVE]
        o.separator ''
      end
    }
  end

  def load_config
    File.open(CONFIG_FILE) do |f|
      config = YAML::load(f)

      @options.server   = config[:server]
      @options.login    = config[:login]
      @options.password = Base64.decode64(config[:password])

      BBBHelper.p_debug 'Configuration loaded from the file: ' + CONFIG_FILE
    end
  rescue
    BBBHelper.p_warning 'Unable to load configuration from the file: ' + CONFIG_FILE
  end

  def save_config
    config = {
      :server => @options.server,
      :login => @options.login,
      :password => Base64.encode64(@options.password)
    }

    Dir.mkdir(File.dirname(CONFIG_FILE)) unless Dir.exist?(File.dirname(CONFIG_FILE))
    File.open(CONFIG_FILE, mode = 'w') {|f| f.puts(config.to_yaml)}

    puts 'Configuration written to the file: ' + CONFIG_FILE
  rescue => exception
    BBBHelper.p_error "Unable to write configuration to the file(#{CONFIG_FILE})"
    raise exception
  end

  def parse(argv)
    @parsers[CMD_GLOBAL].order!(argv)
    argv
  end

  def parse_command(argv)
    raise "No instructions can be found" if argv.empty?

    @command = OpenStruct.new
    @command.instruction = argv.shift
    @command.args = OpenStruct.new

    case @command.instruction
    when CMD_HOURS, CMD_ETA, CMD_FIRST, CMD_LAST
      @command.args       = OpenStruct.new
      @command.args.id    = nil
      @command.args.from  = nil
      @command.args.to    = nil
      @command.args.week  = false

      @parsers[@command.instruction].parse!(argv)
      @command.args.from ||= Date.today

      if @command.args.week
        @command.args.from  = BBBHelper.cwb(@command.args.from)
        @command.args.to    = BBBHelper.cwe(@command.args.from)
      else
        @command.args.to ||= @command.args.from
      end
    when CMD_LOCATE
      @command.args       = OpenStruct.new
      @command.args.id    = nil
      @parsers[@command.instruction].parse!(argv)
    when CMD_QUERY,CMD_SAVE,CMD_EXIT
      @command.args = nil
    end

    @command.clone
  end

  def get_options
    @options
  end
end

begin
  options = BBBOptions.new
  b = BBBrute.new(options)
  b.auth

  argv = options.parse(ARGV)
  command = options.parse_command(argv)

  BBBHelper.debug = options.debug
  BBBHelper.p_debug 'Parsed options: ' + options.get_options.to_s

  b.execute(command)
rescue => exception
  BBBHelper::p_error exception.to_s
  raise exception
end
