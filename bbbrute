#!/usr/bin/ruby

require 'yaml'
require 'json'
require 'openssl'
require 'net/http'
require 'date'
require 'optparse'
require 'ostruct'
require 'base64'
require 'pp'


module StringColors
  def colorize(color_code)
    if $stdout.isatty
      "\e[#{color_code}m#{self}\e[0m"
    else
      self
    end
  end

  def in_red
    colorize(31)
  end

  def in_green
    colorize(32)
  end

  def in_yellow
    colorize(33)
  end

  def in_blue
    colorize(34)
  end

  def in_light_blue
    colorize(36)
  end

  def in_light_grey
    colorize(37)
  end

  def in_light_red
    colorize(91)
  end

  def in_light_yellow
    colorize(93)
  end
end


class String
  include StringColors
end


class BBBHelper
  SECONDS_IN_8H = 28800

  MSG_UNKNOWN_PERSON = 'Неизвестный пользователь'

  MSG_ETA_PLANNED   = 'Запланировано:'
  MSG_ETA_ACTUAL    = 'Отработано:'
  MSG_ETA_TODAY     = 'За сегодня:'
  MSG_ETA_OVERTIME  = 'Переработано:'
  MSG_ETA_REMAINING = 'Недоработано:'
  MSG_ETA_FINISHED  = 'Отработка была в:'
  MSG_ETA_FINISH    = 'Отработка в:'

  MSG_HOURS_HOLIDAY       = 'Выходной'
  MSG_HOURS_DAY_OFF       = 'Отгул'
  MSG_HOURS_VACATION      = 'Отпуск'
  MSG_HOURS_UNPAID_LEAVE  = 'ОЗС'
  MSG_HOURS_SICK_LEAVE    = 'Больничный'
  MSG_HOURS_BUSINESS_TRIP = 'Командировка'
  MSG_HOURS_NO_CONTROL    = 'Снят контроль'


  MSG_GATE_IN = {
    elevator: 'на лифте',
    stairs:   'по лестнице',
    roof:     'с крыши',
    inner:    'через внутреннюю дверь',
    unknown:  'через неизвестную дверь',
    IBM:      'IBM'
  }

  MSG_GATE_OUT = {
    elevator: 'на лифте',
    stairs:   'по лестнице',
    roof:     'на крышу',
    inner:    'через внутреннюю дверь',
    unknown:  'через неизвестную дверь',
    IBM:      'IBM'
  }

  MSG_DIRECTION = {
    in:  'вход',
    out: 'выход'
  }

  MSG_FLOOR_IN = {
    2 => 'втором',
    3 => 'третьем',
    4 => 'четвёртом',
    5 => 'пятом',
    6 => 'шестом',
    7 => 'седьмом',
    8 => 'восьмом',
    9 => 'девятом'
  }

  MSG_FLOOR_OUT = {
    2 => 'второй',
    3 => 'третий',
    4 => 'четвёртый',
    5 => 'пятый',
    6 => 'шестой',
    7 => 'седьмой',
    8 => 'восьмой',
    9 => 'девятый'
  }

  MSG_LOCATE_ABSCENT  = 'не приходил(а)'
  MSG_LOCATE_FLOOR    = 'этаж'
  MSG_LOCATE_IN       = 'на %{floor} этаже'
  MSG_LOCATE_OUT      = 'покинул %{floor} этаж'
  MSG_LOCATE_ROOF     = 'на крыше'
  MSG_LOCATE_INOUT_C  = ' (%{gate} в %{time})'
  MSG_LOCATE_ROOF_C   = ' (выход в %{time})'

  SEPARATOR_HOLIDAY  = '/'
  SEPARATOR_TIME     = ':'
  SEPARATOR_DATE     = '.'


  def self.debug?
    @debug ||= false
  end

  def self.debug=(value)
    @debug = value
  end

  def self.print_ids?
    @print_ids ||= false
  end

  def self.print_ids=(value)
    @print_ids = value
  end

  def self.machine_friendly?
    @machine_friendly ||= false
  end

  def self.machine_friendly=(value)
    @machine_friendly = value
  end

  def self.debug_http_get_headers(request)
    return unless debug?

    STDERR.puts 'GET Request:'.in_light_grey
    STDERR.puts request.path.in_light_grey
    request.each_header {|key,value| STDERR.puts "| #{key} = #{value}".in_light_grey}
  end

  def self.debug_http_response_headers(response)
    return unless debug?

    STDERR.puts 'Response:'.in_light_grey
    STDERR.puts response.inspect.in_light_grey
    response.header.each_header {|key,value| STDERR.puts "| #{key} = #{value}".in_light_grey}
  end

  def self.http_extract_cookies(response)
    all_cookies = response.get_fields('set-cookie')
    unless all_cookies == nil
      cookies_array = Array.new
      all_cookies.each {|cookie| cookies_array.push(cookie.split('; ')[0])}
      $cookies = cookies_array.join('; ')
    end
  rescue
    raise 'Cookies not extracted for an unknown reason.'
  end

  def self.p_dump(filename, contents)
    path = File.join(Dir.home, '.bbbrute', filename)

    if debug?
      File.open(path, 'w') do |file|
        file.write(contents)
      end
    end
  end

  def self.p_debug(lines)
    if debug?
      lines.to_s.split(/\n/).each do |line|
        STDERR.puts "D,#{line}".in_light_grey
      end
    end
  end

  def self.p_warning(lines)
    lines.to_s.split(/\n/).each do |line|
      STDERR.puts "W,#{line}".in_light_yellow
    end
  end

  def self.p_error(lines)
    lines.to_s.split(/\n/).each do |line|
      STDERR.puts "E,#{line}".in_light_red
    end
  end

  def self.cwb(date = Date.today)
    date - date.wday + 1
  end

  def self.cwe(date = Date.today)
    date - date.wday + 7
  end

  def self.cmb(date = Date.today)
    date - date.day + 1
  end

  def self.cme(date = Date.today)
    date = date.next_month
    date - date.day
  end

  def self.timestr_to_seconds(str)
    timearr = str.split(SEPARATOR_TIME).map {|s| s.to_i}
    timearr[0]*3600 + timearr[1]*60 + timearr[2]
  end

  def self.seconds_to_timestr(n)
    n = n.abs

    hours = n / 3600
    r = n % 3600
    minutes = r / 60
    seconds = r % 60

    sprintf('%02d:%02d:%02d', hours, minutes, seconds)
  end

  def self.out_of_office(params)
    s = []
    s << MSG_HOURS_BUSINESS_TRIP if params[:business_trip]
    s << MSG_HOURS_HOLIDAY if params[:holiday]
    s << MSG_HOURS_SICK_LEAVE if params[:sick_leave]
    s << MSG_HOURS_UNPAID_LEAVE if params[:unpaid_leave]
    s << MSG_HOURS_DAY_OFF if params[:day_off]
    s << MSG_HOURS_VACATION if params[:vacation]
    s << MSG_HOURS_NO_CONTROL if params[:no_control]
    return s.join(SEPARATOR_HOLIDAY)
  end

  def self.formatted_printout(format, data)
    if machine_friendly?
      puts JSON.pretty_generate(data)
    else
      data.each do |personal_data|
        message = StringIO.new

        personal_data[:name] ||= MSG_UNKNOWN_PERSON
        personal_data[:id] ||= 0
        if print_ids?
          message.puts "#{personal_data[:name]} (#{personal_data[:id]})".in_blue
        else
          message.puts "#{personal_data[:name]}".in_blue
        end

        if personal_data[:error]
          message.puts '  ' + MSG_LOCATE_ABSCENT.in_red
        else
          p_debug "Printing personal_data (#{format}):"

          case format
          when BBBOptions::CMD_HOURS
            l = find_max_combined_length([MSG_HOURS_HOLIDAY,
                                          MSG_HOURS_DAY_OFF,
                                          MSG_HOURS_VACATION,
                                          MSG_HOURS_UNPAID_LEAVE,
                                          MSG_HOURS_SICK_LEAVE,
                                          MSG_HOURS_BUSINESS_TRIP,
                                          MSG_HOURS_NO_CONTROL])

            personal_data[:hours].each do |h|
              message.printf("  %10s  %8s  %4.2f  %-#{l}s  %s\n",
                             h[:date],
                             h[:hours],
                             h[:rate],
                             out_of_office(h),
                             h[:comments].uniq.join(SEPARATOR_HOLIDAY))
            end
          when BBBOptions::CMD_ETA
            l = find_max_length([MSG_ETA_PLANNED,
                                 MSG_ETA_ACTUAL,
                                 MSG_ETA_TODAY,
                                 MSG_ETA_OVERTIME,
                                 MSG_ETA_REMAINING,
                                 MSG_ETA_FINISHED,
                                 MSG_ETA_FINISH])
            message.printf("  %-#{l}s %11s\n", MSG_ETA_PLANNED, seconds_to_timestr(personal_data[:eta][:planned]))
            message.printf("  %-#{l}s %11s\n", MSG_ETA_ACTUAL, seconds_to_timestr(personal_data[:eta][:actual]))
            message.printf("  %-#{l}s %11s\n", MSG_ETA_TODAY, seconds_to_timestr(personal_data[:eta][:today])) if personal_data[:eta][:today] and personal_data[:eta][:today] != 0
            if personal_data[:eta][:remaining] < 0
              message.printf("  %-#{l}s %11s\n".in_green, MSG_ETA_OVERTIME, seconds_to_timestr(personal_data[:eta][:remaining]))
              message.printf("  %-#{l}s %11s".in_green, MSG_ETA_FINISHED, seconds_to_timestr(personal_data[:eta][:finish])) if personal_data[:eta][:finish]
            else
              message.printf("  %-#{l}s %11s\n".in_red, MSG_ETA_REMAINING, seconds_to_timestr(personal_data[:eta][:remaining]))
              message.printf("  %-#{l}s %11s".in_red, MSG_ETA_FINISH, seconds_to_timestr(personal_data[:eta][:finish])) if personal_data[:eta][:finish]
            end
          when BBBOptions::CMD_ENTRIES
            if personal_data[:pairs]
              lg = find_max_length(MSG_GATE_OUT.values)
              personal_data[:pairs].each do |date, pairs|
                message.puts '  ' + date.in_yellow
                pairs.each do |pair|
                  message.printf("  %d %s:  %#{lg}s  %8s - %8s  %-#{lg}s\n",
                                 pair[:floor],
                                 MSG_LOCATE_FLOOR,
                                 MSG_GATE_IN[pair[:in][:gate]],
                                 pair[:in][:time],
                                 pair[:out][:time],
                                 MSG_GATE_OUT[pair[:out][:gate]])
                end
              end
            else
              lg = find_max_length(MSG_GATE_OUT.values)
              le = find_max_length(MSG_DIRECTION.values)
              personal_data[:entries].each do |date, entries|
                message.puts '  ' + date.in_yellow
                entries.each do |entry|
                  message.printf("  %8s  %d  %-#{le}s  %-#{lg}s\n",
                                 entry[:time],
                                 entry[:door][:floor],
                                 MSG_DIRECTION[entry[:direction]],
                                 entry[:direction] == :in ? MSG_GATE_IN[entry[:door][:gate]] : MSG_GATE_OUT[entry[:door][:gate]])
                end
              end
            end
          when BBBOptions::CMD_LOCATE
            entry = personal_data[:last_entry]

            if entry[:direction] == :out
              message.puts '  ' + MSG_LOCATE_OUT.in_blue % { floor: MSG_FLOOR_OUT[entry[:door][:floor]] } + MSG_LOCATE_INOUT_C.in_light_grey % { gate: MSG_GATE_OUT[entry[:door][:gate]], time: entry[:time] }
            elsif entry[:direction] == :in
              if entry[:door][:floor] == 9 and entry[:door][:gate] == :roof
                message.puts '  ' + MSG_LOCATE_ROOF.in_blue + MSG_LOCATE_INOUT_C.in_light_grey % { time: entry[:time] }
              else
                message.puts '  ' + MSG_LOCATE_IN.in_green % { floor: MSG_FLOOR_IN[entry[:door][:floor]] } + MSG_LOCATE_INOUT_C.in_light_grey % { gate: MSG_GATE_IN[entry[:door][:gate]], time: entry[:time] }
              end
            end
          when BBBOptions::CMD_WATCH
            entry = personal_data[:last_entry]

            if entry[:direction] == :out
              message.puts '  ' + MSG_LOCATE_OUT.in_blue % { floor: MSG_FLOOR_OUT[entry[:door][:floor]] }
            elsif entry[:direction] == :in
              if entry[:door][:floor] == 9 and entry[:door][:gate] == :roof
                message.puts '  ' + MSG_LOCATE_ROOF.in_blue
              else
                message.puts '  ' + MSG_LOCATE_IN.in_green % { floor: MSG_FLOOR_IN[entry[:door][:floor]] }
              end
            end

            message.string.gsub!(/\n+\s*/, ' ') unless $stdout.isatty
          when BBBOptions::CMD_ALIAS
            lk = find_max_length(personal_data.keys)
            lv = find_max_length(personal_data.values.map{|i| i.to_s})
            personal_data.each do |al, id|
              message.printf("%-#{lk}s:  %#{lv}s\n", al.to_s, id.to_s)
            end
          end
        end

        puts message.string
      end
    end

    $stdout.flush
  end

  def self.find_max_length(lines)
    lines.map{|l| l.length}.max
  end

  def self.find_max_combined_length(lines)
    return lines[0].length if lines.count == 1

    lines.sort_by!{|a| a.length}.reverse!
    return lines[0].length + SEPARATOR_HOLIDAY.length + lines[1].length
  end
end


class BBBrute
  SESSION_FILE = File.join(Dir.home, '.bbbrute/cookies.b64')
  WAIT_TIMEOUT = 2

  module STAT
    LATENESS  =  0
    ABSENCE   =  1
    HOURS     =  2
    ENTRIES   =  3
  end

  FLOOR_DATA = {
    '123'                        => {old:true, place: :filimonava},
    '407'                        => {old:true, place: :platonava},
    '2-й этаж, 207 кабинет'      => {floor: 2, gate: :inner},
    '2-й этаж, 212 кабинет'      => {floor: 2, gate: :inner},
    '3-й этаж, лестница'         => {floor: 3, gate: :stairs},
    '3-й этаж, лифт'             => {floor: 3, gate: :elevator},
    '3-й этаж, 306,307 кабинеты' => {floor: 3, gate: :inner},
    '3-й этаж, 306 кабинет'      => {floor: 3, gate: :inner},
    '3-й этаж, 307 кабинет'      => {floor: 3, gate: :inner},
    '3 этаж, 313 кабинет'        => {floor: 3, gate: :inner},
    '4-й этаж, лестница'         => {floor: 4, gate: :stairs},
    '4-й этаж, лифт'             => {floor: 4, gate: :elevator},
    '5-й этаж, лестница'         => {floor: 5, gate: :stairs},
    '5-й этаж, лифт'             => {floor: 5, gate: :elevator},
    '6-й этаж, лестница'         => {floor: 6, gate: :stairs},
    '6-й этаж, лифт'             => {floor: 6, gate: :elevator},
    '6-й этаж, IBM'              => {floor: 6, gate: :IBM},
    '7-й этаж, лестница'         => {floor: 7, gate: :stairs},
    '8-й этаж, лестница'         => {floor: 8, gate: :stairs},
    '9 этаж, спортзал'           => {floor: 9, gate: :roof},
    '9-й этаж, лестница'         => {floor: 9, gate: :stairs},
    '9-й этаж, лифт'             => {floor: 9, gate: :elevator}
  }

  MONTHS = {
    'января'   => '01',
    'февраля'  => '02',
    'марта'    => '03',
    'апреля'   => '04',
    'мая'      => '05',
    'июня'     => '06',
    'июля'     => '07',
    'августа'  => '08',
    'сентября' => '09',
    'октября'  => '10',
    'ноября'   => '11',
    'декабря'  => '12'
  }

  LOGIN_PAGE = 'misc/login.asp'
  DOORS_PAGE = 'Door/DoorPers.asp'
  EMPL_PAGE  = 'List/NetEmpl.asp'
  USERAGENT  = 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.1'

  def initialize(options)
    @options = options

    uri = URI(@options.server)

    OpenSSL::SSL::SSLContext::DEFAULT_PARAMS[:ciphers] += ':DES-CBC3-SHA'
    @http = Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == 'https', verify_mode: OpenSSL::SSL::VERIFY_NONE, open_timeout: 3, read_timeout: 120)
  end

  def build_query(stat, params)
    id = params[:id]
    bdate = params[:bdate]
    edate = params[:edate]
    query = 'Bt=%CF%EE%E8%F1%EA&Period=0'
    query += "&RG=#{stat}"
    query += "&Empl=#{id}" if id
    query += "&bD=#{bdate.day}&bMn=#{bdate.month}&bYr=#{bdate.year}"
    query += "&eD=#{edate.day}&eMn=#{edate.month}&eYr=#{edate.year}"
  end

  def do_auth
    load_session
    if test_connection_response != '200'
      BBBHelper::p_warning 'Session expired. Logging in...'

      uri = URI.join(@options.server, LOGIN_PAGE)
      request = Net::HTTP::Get.new(uri.request_uri, {'user-agent' => USERAGENT})
      request.basic_auth(@options.login, @options.password)
      response = @http.request(request)

      BBBHelper::debug_http_get_headers(request)
      BBBHelper::debug_http_response_headers(response)

      raise 'Authorization failed (401)' if response.code == '401'

      $cookies = BBBHelper::http_extract_cookies(response)
      save_session
    end
  end

  def test_connection_response
    uri = URI.join(@options.server + '/' + EMPL_PAGE)

    request = Net::HTTP::Get.new(uri.request_uri, {'user-agent' => USERAGENT})
    request.basic_auth(@options.login, @options.password)
    request.add_field('cookie', $cookies)
    response = @http.request(request)
    response.code
  end

  def load_session
    f = File.read(SESSION_FILE)
    $cookies = Base64.decode64(f)
    BBBHelper.p_debug 'Session restored from the file: ' + SESSION_FILE
  rescue
    BBBHelper.p_debug 'Unable to restore session from the file: ' + SESSION_FILE
  end

  def save_session
    Dir.mkdir(File.dirname(SESSION_FILE)) unless Dir.exist?(File.dirname(SESSION_FILE))
    File.open(SESSION_FILE, mode = 'w') {|f| f.puts(Base64.encode64($cookies))}
  rescue
    BBBHelper.p_warning "Unable to save session to the file(#{SESSION_FILE})"
  end

  def execute(command, params = {})
    BBBHelper.p_debug 'Parsed command: ' + command.to_s

    if command.instruction == BBBOptions::CMD_SAVE
      @options.save_config
      exit 0
    end

    do_auth

    case command.instruction
    when BBBOptions::CMD_HOURS
      data = doors(command)
      BBBHelper::formatted_printout(BBBOptions::CMD_HOURS, data)
    when BBBOptions::CMD_ETA
      data = doors(command, {fill_eta: true})
      BBBHelper::formatted_printout(BBBOptions::CMD_ETA, data)
    when BBBOptions::CMD_ENTRIES
      data = entries(command)
      BBBHelper::formatted_printout(BBBOptions::CMD_ENTRIES, data)
    when BBBOptions::CMD_LOCATE
      data = entries(command, {find_last_entry: true})
      BBBHelper::formatted_printout(BBBOptions::CMD_LOCATE, data)
    when BBBOptions::CMD_WATCH
      date = Date.today.strftime('%d.%m.%Y')
      last_printed = {}

      loop do
        begin
          data = entries(command, {find_last_entry: true})
        rescue StandardError => e
          BBBHelper.p_warning e.message
        end

        data.each do |person_data|
          id = person_data[:id]
          last_entry = person_data[:last_entry]

          last_printed[id] ||= last_entry unless command.args.locate_first

          case command.args.where
          when nil
            unless last_printed[id] == last_entry
              last_printed[id] = last_entry
              BBBHelper::formatted_printout(BBBOptions::CMD_WATCH, [person_data])
            end
          when 'in', 'out'
            if last_entry[:direction].to_s == command.args.where
              BBBHelper::formatted_printout(BBBOptions::CMD_WATCH, [person_data])
              exit 0
            end
          else
            if last_entry[:direction] == :in and last_entry[:door][:floor].to_s == command.args.where
              BBBHelper::formatted_printout(BBBOptions::CMD_WATCH, [person_data])
              exit 0
            end
          end
        end

        sleep WAIT_TIMEOUT
      end
    when BBBOptions::CMD_PRESENCE
      data = entries(command)
      BBBHelper::formatted_printout(BBBOptions::CMD_PRESENCE, data)
    when BBBOptions::CMD_ALIAS
      if command.args.list
        cache = @options.load_cache
        if cache and cache[:aliases]
          BBBHelper::formatted_printout(BBBOptions::CMD_ALIAS, cache[:aliases])
        end
      else
        @options.to_cache({aliases: {op: :add, alias: command.args.alias, ids: command.args.ids}})
      end
    when BBBOptions::CMD_QUERY
      if params[:query_mode]
        puts 'Unable to execute while in query mode.'
      else
        printf "Enter 'exit' to quit.\n> "
        while input = gets
          begin
          input_argv = input.chomp.split(/\s/)
          query_command = @options.parse_command(input_argv)
          execute(query_command, {query_mode: true})
          printf '> '
          rescue StandardError => exception
            BBBHelper::p_error exception.to_s
          end
        end
      end
    when BBBOptions::CMD_EXIT
      if params[:query_mode]
        exit 0
      else
        puts 'Unrecognized command: ' + command.instruction.to_s
        exit 1
      end
    else
      puts 'Unrecognized command: ' + command.instruction.to_s
      exit 1 unless params[:query_mode]
    end
  end

  def doors(command, params = {})
    results = command.args.ids.map do |id|
      uri = URI.join(@options.server + '/' + DOORS_PAGE + '?' + build_query(STAT::HOURS, {
        :id => (id == 0 ? nil : id),
        :bdate => command.args.from,
        :edate => command.args.to}))

      BBBHelper::p_debug "uri='#{uri}'"
      request = Net::HTTP::Get.new(uri.request_uri, {'user-agent' => USERAGENT})
      request.basic_auth(@options.login, @options.password)
      request.add_field('cookie', $cookies)
      response = @http.request(request)

      BBBHelper::debug_http_get_headers(request)
      BBBHelper::debug_http_response_headers(response)

      BBBHelper::p_debug "#{id} #{response.inspect}"

      body = response.body.force_encoding('CP1251').encode('UTF-8')

      BBBHelper::p_dump('doors.html', body)

      parsed_data = nil

      if body_dissect = body.match(/<TR><TD ALIGN=Right rowspan=(\d+)>1.<TD rowspan=\d+><a href=\.\.\/misc\/PersInfo\.asp\?ID=(\d+)>(.*?)<\/a><\/td>(.*)<\/tr><TR><TD ALIGN=Left bgcolor = Silver>/)

        parsed_data= {}
        parsed_data[:count] = body_dissect.captures[0].to_i - 1
        BBBHelper.p_debug '#    = ' + parsed_data[:count].to_s

        parsed_data[:id] = body_dissect.captures[1].to_i
        BBBHelper.p_debug 'Id   = ' + parsed_data[:id].to_s

        parsed_data[:name] = body_dissect.captures[2]
        BBBHelper.p_debug 'Name = ' + parsed_data[:name]

        rawdata = body_dissect.captures[3]
        BBBHelper.p_debug "Data = #{rawdata.length}B"

        parsed_data[:hours] = rawdata.split('<tr>').map do |line|
          hours_data = {
            holiday:        false,
            date:           nil,
            hours:          nil,
            rate:           nil,
            day_off:        nil,
            vacation:       nil,
            unpaid_leave:   nil,
            sick_leave:     nil,
            business_trip:  nil,
            no_control:     nil,
            comments:       []
          }

          if h = line.scan(/<TD.*?>(.*?)<\/TD>/)
            hours_data[:holiday] = true if h[0][0].match(/Red/)
            hours_data[:date]           = h[0][0].gsub(/[^0-9.]+/, '')
            hours_data[:hours]          = h[1][0].gsub(/[^0-9:]+/, '')
            hours_data[:rate]           = h[2][0].sub(',', '.').to_f
            [
              {index: 3, atom: :day_off},
              {index: 4, atom: :vacation},
              {index: 5, atom: :unpaid_leave},
              {index: 6, atom: :sick_leave},
              {index: 7, atom: :business_trip},
              {index: 8, atom: :no_control}
            ].each do |field|
              if h[field[:index]][0] != '&nbsp'
                hours_data[field[:atom]] = true
                if c = h[field[:index]][0].match(/ALT = "(.*?)"/)
                  hours_data[:comments] << c.captures[0]
                end
              end
            end
          end

          hours_data
        end
      end

      if params[:fill_eta]
        parsed_data = fill_eta(command, parsed_data)
        parsed_data.tap { |pd| pd.delete(:hours) }
      end

      parsed_data ||= {id: id, error: true, error_msg: :no_data_found}
    end

    BBBHelper::p_debug 'Result from doors:'
    BBBHelper::p_debug results
    return results
  end

  def entries(command, params = {})
    results = command.args.ids.map do |id|
      uri = URI.join(@options.server + '/' + DOORS_PAGE + '?' + build_query(STAT::ENTRIES, {
        :id => (id == 0 ? nil : id),
        :bdate => command.args.from,
        :edate => command.args.to}))

      BBBHelper::p_debug "uri='#{uri}'"
      request = Net::HTTP::Get.new(uri.request_uri, {'user-agent' => USERAGENT})
      request.basic_auth(@options.login, @options.password)
      request.add_field('cookie', $cookies)
      response = @http.request(request)

      BBBHelper::debug_http_get_headers(request)
      BBBHelper::debug_http_response_headers(response)

      BBBHelper::p_debug "#{id} #{response.inspect}"

      body = response.body.force_encoding('CP1251').encode('UTF-8')

      BBBHelper::p_dump('entries.html', body)

      parsed_data = nil

      if body_dissect = body.match(/<TR><TD ALIGN=Right rowspan=(\d+)>1.<TD rowspan=\d+><a href=\.\.\/misc\/PersInfo\.asp\?ID=(\d+)>(.*?)<\/a><\/td>(.*)<\/tr><\/Table>/)

        parsed_data= {}
        parsed_data[:count] = body_dissect.captures[0].to_i
        BBBHelper.p_debug '#    = ' + parsed_data[:count].to_s

        parsed_data[:id] = body_dissect.captures[1].to_i
        BBBHelper.p_debug 'Id   = ' + parsed_data[:id].to_s

        parsed_data[:name] = body_dissect.captures[2]
        BBBHelper.p_debug 'Name = ' + parsed_data[:name]

        rawdata = body_dissect.captures[3]
        BBBHelper.p_debug "Data = #{rawdata.length}B"

        parsed_data[:entries] = {}

        rawdata.split('<tr>').map do |line|
          if e = line.scan(/<TD.*?>(.*?)<\/TD>/)
            date_p = e[0][0].split(' ')
            date_p[0] = '0' + date_p[0] if date_p[0].length == 1
            date_p[1] = MONTHS[date_p[1]]

            date = date_p.take(3).join(BBBHelper::SEPARATOR_DATE)

            parsed_data[:entries][date] = [] unless parsed_data[:entries][date]

            door =   FLOOR_DATA[e[2][0].scan(/(?<=&nbsp;)(.*?)(?=&nbsp;)/).join]
            door ||= {
              floor: ("0" + e[2][0].scan(/(?<=&nbsp;)(.*?)(?= этаж)/).join).to_i,
              gate:  :unknown
            }

            pass = {
              time:      e[1][0].gsub(/[^0-9:]+/, ''),
              door:      door,
              direction: nil
            }

            if e[3][0].include? 'Вход'
              pass[:direction] = :in
            elsif e[3][0].include? 'Выход'
              pass[:direction] = :out
            end

            parsed_data[:entries][date] << pass
          end
        end
      end

      unless command.args.plain or parsed_data.nil?
        parsed_data[:pairs] = {}
        parsed_data[:entries].each do |date,entries|
          parsed_data[:pairs][date] = []

          pair = {
            floor: nil,
            in:    {},
            out:   {}
          }

          entries.each do |e|
            if pair[:floor].nil?
              pair[:floor] = e[:door][:floor]
              pair[e[:direction]][:time] = e[:time]
              pair[e[:direction]][:gate] = e[:door][:gate]
            else
              if pair[:floor] == e[:door][:floor] # TODO: Implement Unknown door identification if e[:door] is nil
                if pair[:out].empty? and e[:direction] == :out
                  pair[:out][:time] = e[:time]
                  pair[:out][:gate] = e[:door][:gate]
                else
                  parsed_data[:pairs][date] << pair
                  pair = {
                    floor: nil,
                    in:    {},
                    out:   {}
                  }
                  pair[:floor] = e[:door][:floor]
                  pair[e[:direction]][:time] = e[:time]
                  pair[e[:direction]][:gate] = e[:door][:gate]
                end
              else
                parsed_data[:pairs][date] << pair
                pair = {
                  floor: nil,
                  in:    {},
                  out:   {}
                }

                pair[:floor] = e[:door][:floor]
                pair[e[:direction]][:time] = e[:time]
                pair[e[:direction]][:gate] = e[:door][:gate]
              end
            end
          end
          parsed_data[:pairs][date] << pair
        end
      end

      if params[:find_last_entry]
        if parsed_data and parsed_data[:entries] and not parsed_data[:entries].empty?
          parsed_data[:last_entry] = parsed_data[:entries].first[1].last
          parsed_data.tap { |pd| pd.delete(:entries) }
          parsed_data.tap { |pd| pd.delete(:pairs) }
        end
      end

      parsed_data ||= {id: id, error: true, error_msg: :no_data_found}
    end

    BBBHelper::p_debug "Result from entries:"
    BBBHelper::p_debug results
    return results
  end

  def fill_eta(command, data)
    today = 0

    data[:eta] = data[:hours].map do |h|
      BBBHelper.p_debug "Extracted date: " + h[:date]

      if h[:date] == Date.today.strftime('%d.%m.%Y')
        today = BBBHelper.timestr_to_seconds(h[:hours])
      end

      if h[:holiday] or h[:day_off] or h[:vacation] or
        h[:unpaid_leave] or h[:sick_leave] or
        h[:business_trip] or h[:no_control]
        {date: h[:date], planned: 0, actual: 0}
      else
        planned_load = (h[:rate]*BBBHelper::SECONDS_IN_8H).round
        actual = BBBHelper.timestr_to_seconds(h[:hours])

        {
          date: h[:date],
          planned: planned_load,
          actual: actual
        }
      end
    end.reduce do |h1, h2|
      {planned: h1[:planned] + h2[:planned], actual: h1[:actual] + h2[:actual]}
    end

    data[:eta][:today] = today

    data[:eta][:remaining] = data[:eta][:planned] - data[:eta][:actual]
    if command.args.to >= Date.today
      data[:eta][:finish] = Time.now.to_i - Date.today.to_time.to_i + data[:eta][:remaining]
    end
    data
  end
end


class BBBOptions
  CONFIG_FILE = File.join(Dir.home, '.bbbrute', 'config.yml')
  CACHE_FILE  = File.join(Dir.home, '.bbbrute', 'cache.yml')

  DAYS_PER_WEEK = 7

  CMD_GLOBAL      = ''
  CMD_HOURS       = 'hours'
  CMD_ETA         = 'eta'
  CMD_ENTRIES     = 'entries'
  CMD_LOCATE      = 'locate'
  CMD_WATCH       = 'watch'
  CMD_PRESENCE    = 'presence'
  CMD_ALIAS       = 'alias'
  CMD_SAVE        = 'save'
  CMD_QUERY       = 'query'
  CMD_EXIT        = 'exit'

  MSG_USAGE                   = 'Usage: %s [OPTIONS...] COMMAND [ARGS...]'
  MSG_DESCRIPTION             = 'BBBrute exists to help you with the analysis of timesheets'
  MSG_COMMAND_PRINTOUT        = '%s (%s)'
  MSG_SEPARATOR_OPTIONS       = 'OPTIONS'
  MSG_SEPARATOR_COMMANDS      = 'COMMANDS'
  MSG_DESCRIPTION_HOURS       = 'Print hours worked by person during a selected period'
  MSG_DESCRIPTION_ETA         = 'Calculated remaining workload for a selected period'
  MSG_DESCRIPTION_ENTRIES     = 'Print all entries by person during a selected period'
  MSG_DESCRIPTION_LOCATE      = 'Find out, where is person now, looking by the last entry'
  MSG_DESCRIPTION_WATCH       = 'Watch all entries of a person'
  MSG_DESCRIPTION_PRESENCE    = 'List all first and last entries during a selected period'
  MSG_DESCRIPTION_ALIAS       = 'Manage aliases'
  MSG_DESCRIPTION_SAVE        = 'Save entered global options for future use'
  MSG_DESCRIPTION_QUERY       = 'Interactive mode. Usage: COMMAND [ARGS...]'
  MSG_OPTION_HELP             = 'Show help message'
  MSG_OPTION_PRINT_IDS        = 'Print id along with name'
  MSG_OPTION_DEBUG            = 'Print debug information'
  MSG_OPTION_SERVER           = 'Address of the timesheets server (example: https://example.org)'
  MSG_OPTION_LOGIN            = 'Domain login of the user with access to the timesheets server'
  MSG_OPTION_PASSWORD         = 'Password of the user with access to the timesheets server'
  MSG_OPTION_MACHINE          = 'Output data as a JSON for further processing'
  MSG_ARGUMENT_ID             = 'ID or alias of the person to check timesheet for (default: logged user)'
  MSG_ARGUMENT_FROM           = 'Beginning of the date range to check (default: today)'
  MSG_ARGUMENT_TO             = 'End of the date range to check (default: today)'
  MSG_ARGUMENT_MONTH          = 'Calculate for current month (optionally: N months back)'
  MSG_ARGUMENT_WEEK           = 'Calculate for current week (optionally: N weeks back)'
  MSG_ARGUMENT_WHERE          = 'Expected location: "in", "out", or floor number. If set, exits after first occurence.'
  MSG_ARGUMENT_LOCATE_FIRST   = 'Make initial querry of the location prior tracking (default: true for single user, false for groups)'
  MSG_ARGUMENT_PLAIN          = 'Do not use paired printout of linked ins and outs'
  MSG_ARGUMENT_ALIAS_ID       = 'ID to create alias for'
  MSG_ARGUMENT_ALIAS_NAME     = 'Desired alias name'
  MSG_ARGUMENT_ALIAS_LIST     = 'List existing aliases'
  MSG_ALIAS_NOT_FOUND         = 'No suitable alias found'
  MSG_ALIAS_MULTIPLE_FOUND    = 'Multiple aliases detected'

  def initialize
    @options = OpenStruct.new
    @options.debug            = false
    @options.server           = nil
    @options.login            = nil
    @options.password         = nil
    @options.machine_friendly = false

    @session = OpenStruct.new
    @session.config = nil

    load_config
    load_session
    setup_parsers
  end

  def method_missing(method, *args, &block)
    @options.send(method, *args, &block)
  end

  def exec_help_printout
    @parsers.each do |parser_name, parser_scheme|
      puts parser_scheme
    end

    exit 0
  end

  def setup_parsers
    @parsers = {
      CMD_GLOBAL => OptionParser.new do |o|
        o.banner = MSG_USAGE % File.basename($0)
        o.separator MSG_DESCRIPTION
        o.separator ''
        o.separator MSG_SEPARATOR_OPTIONS

        o.on('-h', '--help', MSG_OPTION_HELP)\
          { exec_help_printout }

        o.on('-i', '--[no-]print-ids', MSG_OPTION_PRINT_IDS)\
          {|b| @options.print_ids = b}

        o.on('-d', '--[no-]debug', MSG_OPTION_DEBUG)\
          {|b| @options.debug = b}

        o.on('-s', '--server HOSTNAME', String, MSG_OPTION_SERVER)\
          {|s| @options.server = s}

        o.on('-l', '--login LOGIN', String, MSG_OPTION_LOGIN)\
          {|s| @options.login = s}

        o.on('-p', '--password PASSWORD', String, MSG_OPTION_PASSWORD)\
          {|s| @options.password = s}

        o.on('-m', '--[no-]machine-friendly', MSG_OPTION_MACHINE)\
          {|b| @options.machine_friendly = b}

        o.separator ''
        o.separator MSG_SEPARATOR_COMMANDS
      end,

      CMD_HOURS => OptionParser.new do |o|
        o.banner = MSG_COMMAND_PRINTOUT % [CMD_HOURS, MSG_DESCRIPTION_HOURS]

        o.on('-i', '--id ID', String, MSG_ARGUMENT_ID)\
          {|s| @command.args.ids = find_ids(s)}

        o.on('-f', '--from DD.MM.YYYY', String, MSG_ARGUMENT_FROM)\
          {|s| @command.args.from = Date.parse(s)}

        o.on('-t', '--to DD.MM.YYYY', String, MSG_ARGUMENT_TO)\
          {|s| @command.args.to = Date.parse(s)}

        o.on('-m', '--month[=N]', Integer, MSG_ARGUMENT_MONTH)\
          {|n| @command.args.month = n || 0}

        o.on('-w', '--week[=N]', Integer, MSG_ARGUMENT_WEEK)\
          {|n| @command.args.week = n || 0}

        o.separator ''
      end,

      CMD_ETA => OptionParser.new do |o|
        o.banner = MSG_COMMAND_PRINTOUT % [CMD_ETA, MSG_DESCRIPTION_ETA]

        o.on('-i', '--id ID', String, MSG_ARGUMENT_ID)\
          {|s| @command.args.ids = find_ids(s)}

        o.on('-f', '--from DD.MM.YYYY', String, MSG_ARGUMENT_FROM)\
          {|s| @command.args.from = Date.parse(s)}

        o.on('-t', '--to DD.MM.YYYY', String, MSG_ARGUMENT_TO)\
          {|s| @command.args.to = Date.parse(s)}

        o.on('-m', '--month[=N]', Integer, MSG_ARGUMENT_MONTH)\
          {|n| @command.args.month = n || 0}

        o.on('-w', '--week[=N]', Integer, MSG_ARGUMENT_WEEK)\
          {|n| @command.args.week = n || 0}

        o.separator ''
      end,

      CMD_ENTRIES => OptionParser.new do |o|
        o.banner = MSG_COMMAND_PRINTOUT % [CMD_ENTRIES, MSG_DESCRIPTION_ENTRIES]

        o.on('-i', '--id ID', String, MSG_ARGUMENT_ID)\
          {|s| @command.args.ids = find_ids(s)}

        o.on('-f', '--from DD.MM.YYYY', String, MSG_ARGUMENT_FROM)\
          {|s| @command.args.from = Date.parse(s)}

        o.on('-t', '--to DD.MM.YYYY', String, MSG_ARGUMENT_TO)\
          {|s| @command.args.to = Date.parse(s)}

        o.on('-m', '--month[=N]', Integer, MSG_ARGUMENT_MONTH)\
          {|n| @command.args.month = n || 0}

        o.on('-w', '--week[=N]', Integer, MSG_ARGUMENT_WEEK)\
          {|n| @command.args.week = n || 0}

        o.on('-p', '--[no-]plain', MSG_ARGUMENT_PLAIN)\
          {|b| @command.args.plain = b}

        o.separator ''
      end,

      CMD_LOCATE => OptionParser.new do |o|
        o.banner = MSG_COMMAND_PRINTOUT % [CMD_LOCATE, MSG_DESCRIPTION_LOCATE]

        o.on('-i', '--id ID', String, MSG_ARGUMENT_ID)\
          {|s| @command.args.ids = find_ids(s)}

        o.separator ''
      end,

      CMD_WATCH => OptionParser.new do |o|
        o.banner = MSG_COMMAND_PRINTOUT % [CMD_WATCH, MSG_DESCRIPTION_WATCH]

        o.on('-i', '--id ID', String, MSG_ARGUMENT_ID)\
          {|s| @command.args.ids = find_ids(s)}

        o.on('-w', '--where WHERE', String, MSG_ARGUMENT_WHERE)\
          {|s| @command.args.where = s}

        o.on('-l', '--locate-first', MSG_ARGUMENT_LOCATE_FIRST)\
          {|b| @command.args.locate_first = b}

        o.separator ''
      end,

      CMD_PRESENCE => OptionParser.new do |o|
        o.banner = MSG_COMMAND_PRINTOUT % [CMD_PRESENCE, MSG_DESCRIPTION_PRESENCE]

        o.on('-i', '--id ID', String, MSG_ARGUMENT_ID)\
          {|s| @command.args.ids = find_ids(s)}

        o.on('-f', '--from DD.MM.YYYY', String, MSG_ARGUMENT_FROM)\
          {|s| @command.args.from = Date.parse(s)}

        o.on('-t', '--to DD.MM.YYYY', String, MSG_ARGUMENT_TO)\
          {|s| @command.args.to = Date.parse(s)}

        o.separator ''
      end,

      CMD_ALIAS => OptionParser.new do |o|
        o.banner = MSG_COMMAND_PRINTOUT % [CMD_ALIAS, MSG_DESCRIPTION_ALIAS]

        o.on('-i', '--id ID', String, MSG_ARGUMENT_ALIAS_ID)\
          {|s| @command.args.ids = find_ids(s)}

        o.on('-a', '--alias ALIAS', String, MSG_ARGUMENT_ALIAS_NAME)\
          {|s| @command.args.alias = s}

        o.on('-l', '--[no-]list', MSG_ARGUMENT_ALIAS_LIST)\
          {|b| @command.args.list = b}

        o.separator ''
      end,

      CMD_SAVE => OptionParser.new do |o|
        o.banner = MSG_COMMAND_PRINTOUT % [CMD_SAVE, MSG_DESCRIPTION_SAVE]
        o.separator ''
      end,

      CMD_QUERY => OptionParser.new do |o|
        o.banner = MSG_COMMAND_PRINTOUT % [CMD_QUERY, MSG_DESCRIPTION_QUERY]
        o.separator ''
      end
    }
  end

  def load_config
    File.open(CONFIG_FILE) do |f|
      config = YAML::load(f)

      @options.server   = config[:server]
      @options.login    = config[:login]
      @options.password = Base64.decode64(config[:password])
    end
  rescue
    BBBHelper.p_warning 'Unable to load configuration from the file: ' + CONFIG_FILE
  end

  def save_config
    config = {
      :server => @options.server,
      :login => @options.login,
      :password => Base64.encode64(@options.password)
    }

    Dir.mkdir(File.dirname(CONFIG_FILE)) unless Dir.exist?(File.dirname(CONFIG_FILE))
    File.open(CONFIG_FILE, mode = 'w') {|f| f.puts(config.to_yaml)}

    puts 'Configuration written to the file: ' + CONFIG_FILE
  rescue StandardError => exception
    BBBHelper.p_error "Unable to write configuration to the file(#{CONFIG_FILE})"
    raise exception
  end

  def find_ids(input)
    input.split(',').map {|s| Integer(s)}
  rescue
    aliases = load_cache[:aliases]
    aliases.select! {|k,v| k.to_s.match /#{input}/}

    if aliases.length == 1
      if aliases.values.first.kind_of?(Integer)
        return [aliases.values.first]
      else
        return aliases.values.first
      end
    end

    if aliases.length == 0
      BBBHelper::p_error MSG_ALIAS_NOT_FOUND
    else
      BBBHelper::p_error MSG_ALIAS_MULTIPLE_FOUND
      BBBHelper::formatted_printout(BBBOptions::CMD_ALIAS, aliases)
    end

    exit 1
  end

  def find_alias(input)
    String(input)
  rescue
    aliases = load_cache[:aliases]
    aliases.select! {|k,v| v.to_s.match /#{input.to_s}/}

    return aliases.keys.first if aliases.length == 1

    if aliases.length == 0
      BBBHelper::p_error MSG_ALIAS_NOT_FOUND
    else
      BBBHelper::p_error MSG_ALIAS_MULTIPLE_FOUND
      BBBHelper::formatted_printout(BBBOptions::CMD_ALIAS, aliases)
    end

    exit 1
  end

  def load_cache(root = nil)
    File.open(CACHE_FILE) {|f| YAML::load(f)}
  rescue
    BBBHelper.p_warning 'Unable to load cache from the file: ' + CACHE_FILE
    {}
  end

  def to_cache(params)
    cache = load_cache

    if params[:aliases]
      cache[:aliases] = {} unless cache[:aliases]

      case params[:aliases][:op]
      when :add
        raise "Cannot save alias: wrong input." \
          if params[:aliases][:alias].nil? or params[:aliases][:ids].nil?
        cache[:aliases][params[:aliases][:alias]] = params[:aliases][:ids]
      end
    end

    Dir.mkdir(File.dirname(CACHE_FILE)) unless Dir.exist?(File.dirname(CACHE_FILE))
    File.open(CACHE_FILE, mode = 'w') {|f| f.puts(cache.to_yaml)}
  rescue => exception
    BBBHelper.p_error "Unable to write cache to the file(#{CACHE_FILE})"
    raise exception
  end

  def parse(argv)
    @parsers[CMD_GLOBAL].order!(argv)
    BBBHelper.debug = @options.debug
    argv
  end

  def parse_command(argv)
    raise "No instructions can be found" if argv.empty?

    @command = OpenStruct.new
    @command.instruction = argv.shift
    @command.args = OpenStruct.new

    case @command.instruction
    when CMD_HOURS, CMD_ETA, CMD_PRESENCE
      @command.args       = OpenStruct.new
      @command.args.ids   = [0]
      @command.args.from  = nil
      @command.args.to    = nil
      @command.args.week  = false
      @command.args.month = false

      @parsers[@command.instruction].parse!(argv)

      if @command.args.month
        @command.args.from = Date.today.prev_month(@command.args.month)
        @command.args.from = BBBHelper.cmb(@command.args.from)
        @command.args.to   = BBBHelper.cme(@command.args.from)
      elsif @command.args.week
        @command.args.from = Date.today.prev_day(@command.args.week * DAYS_PER_WEEK)
        @command.args.from = BBBHelper.cwb(@command.args.from)
        @command.args.to   = BBBHelper.cwe(@command.args.from)
      else
        @command.args.from ||= Date.today
        @command.args.to   ||= Date.today
      end
    when CMD_ENTRIES
      @command.args       = OpenStruct.new
      @command.args.ids   = [0]
      @command.args.from  = nil
      @command.args.to    = nil
      @command.args.week  = false
      @command.args.month = false
      @command.args.plain = false

      @parsers[@command.instruction].parse!(argv)

      if @command.args.month
        @command.args.from = Date.today.prev_month(@command.args.month)
        @command.args.from = BBBHelper.cmb(@command.args.from)
        @command.args.to   = BBBHelper.cme(@command.args.from)
      elsif @command.args.week
        @command.args.from = Date.today.prev_day(@command.args.week * DAYS_PER_WEEK)
        @command.args.from = BBBHelper.cwb(@command.args.from)
        @command.args.to   = BBBHelper.cwe(@command.args.from)
      else
        @command.args.from ||= Date.today
        @command.args.to   ||= Date.today
      end
    when CMD_LOCATE
      @command.args       = OpenStruct.new
      @command.args.ids   = [0]
      @command.args.from  = Date.today
      @command.args.to    = Date.today
      @parsers[@command.instruction].parse!(argv)
    when CMD_WATCH
      @command.args              = OpenStruct.new
      @command.args.ids          = [0]
      @command.args.from         = Date.today
      @command.args.to           = Date.today
      @command.args.where        = nil
      @command.args.locate_first = nil
      @parsers[@command.instruction].parse!(argv)
      unless @command.args.locate_first
        if @command.args.ids.count > 1
          @command.args.locate_first = false
        else
          @command.args.locate_first = true
        end
      end
    when CMD_ALIAS
      @command.args       = OpenStruct.new
      @command.args.ids   = [0]
      @command.args.alias = nil
      @parsers[@command.instruction].parse!(argv)
    when CMD_SAVE,CMD_QUERY,CMD_EXIT
      @command.args = nil
    end

    @command.clone
  end

  def get_options
    @options
  end
end

begin
  options = BBBOptions.new
  argv = options.parse(ARGV)

  b = BBBrute.new(options)

  command = options.parse_command(argv)

  BBBHelper.debug = options.debug
  BBBHelper.print_ids = options.print_ids
  BBBHelper.machine_friendly = options.machine_friendly

  BBBHelper.p_debug 'Parsed options: ' + options.get_options.to_s

  b.execute(command)
rescue Net::OpenTimeout, Net::ReadTimeout
  puts 'Server is inaccessible'.in_red
  exit 10
rescue StandardError => exception
  BBBHelper::p_error exception.full_message if BBBHelper.debug?
rescue Interrupt
  puts
  exit 0
end
