#!/usr/bin/ruby

require 'yaml'
require 'openssl'
require 'net/http'
require 'date'
require 'optparse'
require 'ostruct'
require 'base64'

class BBBHelper
  def self.debug?
    @debug ||= false
  end

  def self.debug=(value)
    @debug = value
  end

  def self.debug_http_get_headers(request)
    return unless debug?

    STDERR.puts 'GET Request:'
    STDERR.puts request.path
    request.each_header {|key,value| STDERR.puts "| #{key} = #{value}" }
  end

  def self.debug_http_response_headers(response)
    return unless debug?

    STDERR.puts 'Response:'
    STDERR.puts response.inspect
    response.header.each_header {|key,value| STDERR.puts "| #{key} = #{value}" }
  end

  def self.http_extract_cookies(response)
    all_cookies = response.get_fields('set-cookie')
    unless all_cookies == nil
      cookies_array = Array.new
      all_cookies.each { |cookie|
        cookies_array.push(cookie.split('; ')[0])
      }
      $cookies = cookies_array.join('; ')
    end
  rescue
    raise 'Cookies not extracted for an unknown reason.'
  end

  def self.p_debug(lines)
    if debug?
      lines.split("\n").each do |line|
        STDERR.puts "D,#{line}"
      end
    end
  end

  def self.p_warning(lines)
    if debug?
      lines.split("\n").each do |line|
        STDERR.puts "W,#{line}"
      end
    end
  end

  def self.p_error(lines)
    if debug?
      lines.split("\n").each do |line|
        STDERR.puts "E,#{line}"
      end
    end
  end
end


class BBBrute
  module STAT
    LATENESS  =  0
    ABSENCE   =  1
    TIMES     =  2
    DOORS     =  3
  end

  LOGIN_PAGE = 'misc/login.asp'
  DOORS_PAGE = 'Door/DoorPers.asp'
  USERAGENT  = 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.1'

  def initialize(options)
    @options = options

    uri = URI(@options.server)

    @http = Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == 'https', verify_mode: OpenSSL::SSL::VERIFY_NONE)
  end

  def query(stat, params)
    id = params[:id]
    bdate = params[:bdate]
    edate = params[:edate]
    query = 'Bt=%CF%EE%E8%F1%EA&Period=0'
    query += "&RG=#{stat}"
    query += "&Empl=#{id}" if id
    query += "&bD=#{bdate.day}&bMn=#{bdate.month}&bYr=#{bdate.year}"
    query += "&eD=#{edate.day}&eMn=#{edate.month}&eYr=#{edate.year}"
  end

  def auth
    uri = URI.join(@options.server, LOGIN_PAGE)
    request = Net::HTTP::Get.new(uri.request_uri, {'user-agent' => USERAGENT})
    request.basic_auth(@options.login, @options.password)
    response = @http.request(request)

    BBBHelper::debug_http_get_headers(request)
    BBBHelper::debug_http_response_headers(response)

    raise 'Authorization failed (401)' if response.code == '401'

    $cookies = BBBHelper::http_extract_cookies(response)
  end

  def cwb(date = Date.today)
    date - date.wday + 1
  end

  def cwe(date = Date.today)
    date - date.wday + 7
  end

  def doors
    uri = URI.join(@options.server + '/' + DOORS_PAGE + '?' + query(STAT::TIMES, {:id => @options.id, :bdate => @options.from, :edate => @options.until}))

    request = Net::HTTP::Get.new(uri.request_uri, {'user-agent' => USERAGENT})
    request.basic_auth(@options.login, @options.password)
    request.add_field('cookie', $cookies)
    response = @http.request(request)

    BBBHelper::debug_http_get_headers(request)
    BBBHelper::debug_http_response_headers(response)

    BBBHelper::p_debug "#{@options.id} #{response.inspect}"

    body = response.body.force_encoding('CP1251').encode('UTF-8')

    BBBHelper::p_debug 'BODY'
    BBBHelper::p_debug body
    BBBHelper::p_debug 'END BODY'

    link = body.match(/<a href=\.\.\/misc\/PersInfo\.asp\?ID=[0-9]+>(.*)<\/a>/)

    unless link.nil?
      puts link
    end
  end
end


class BBBOptions
  CONFIG_FILE = File.join(Dir.home, '.bbbrute/config.yml')

  MSG_COMMAND_NAME = 'Command: %s'

  def initialize
    @options = OpenStruct.new
    @options.debug            = false
    @options.server           = nil
    @options.login            = nil
    @options.password         = nil
    @options.machine_friendly = false
    @options.command          = nil
    @options.command_args     = nil

    load_config
    setup_parsers
  end

  def method_missing(method, *args, &block)
    @options.send(method, *args, &block)
  end

  def exec_help_printout
    @parsers.each do |parser_name, parser_scheme|
      puts parser_scheme
    end

    exit 0
  end

  def define_parser_global
    parser_name = ''

    @parsers[parser_name] = OptionParser.new

    @parsers[parser_name].banner =  "Usage: #{File.basename($0)} [OPTION...] COMMAND COMMAND_ARG..."
    @parsers[parser_name].separator 'BBBrute exists to help you with the analysis of timesheets'
    @parsers[parser_name].separator ''
    @parsers[parser_name].separator 'OPTIONS'

    @parsers[parser_name].on('-h', '--help',
               'Show help message') do
      exec_help_printout
    end

    @parsers[parser_name].on('-d', '--[no-]debug',
               'More info for debug purposes') do |b|
      @options.debug = b
    end

    @parsers[parser_name].on('-s', '--server HOSTNAME', String,
               'Target for BBBrute: https://example.org') do |s|
      @options.server = s
    end

    @parsers[parser_name].on('-l', '--login LOGIN', String,
               'User login to access target server') do |s|
      @options.login = s
    end

    @parsers[parser_name].on('-p', '--password PASSWORD', String,
               'Password to access target server') do |s|
      @options.password = s
    end

    @parsers[parser_name].on('-m', '--[no-]machine-friendly',
               'Output data in CSV') do |b|
      @options.machine_friendly = b
    end

    @parsers[parser_name].separator ''
  end

  def define_parser_hours
    parser_name = 'hours'

    @options.command_args       = OpenStruct.new
    @options.command_args.id    = nil
    @options.command_args.from  = nil
    @options.command_args.until = nil

    @parsers[parser_name] = OptionParser.new
    @parsers[parser_name].banner = MSG_COMMAND_NAME % parser_name
    @parsers[parser_name].separator 'Get hours worked by person.'

    @parsers[parser_name].on('-i', '--id ID', Integer, 'ID of the person to check') do |i|
      @options.command_args.id = i
    end

    @parsers[parser_name].on('-f', '--from DD.MM.YYYY', String,
               'First day to request info, Default: today') do |s|
      @options.command_args.from = Date.parse(s)
    end

    @parsers[parser_name].on('-t', '--till DD.MM.YYYY', String,
               'First day to request info, Default: FROM') do |s|
      @options.command_args.until = Date.parse(s)
    end

    @parsers[parser_name].separator ''
  end

  def define_parser_where
    parser_name = 'where'

    @options.command_args       = OpenStruct.new
    @options.command_args.id    = nil

    @parsers[parser_name] = OptionParser.new
    @parsers[parser_name].banner = MSG_COMMAND_NAME % parser_name
    @parsers[parser_name].separator 'Locate person'

    @parsers[parser_name].on('-i', '--id ID', Integer, 'ID of the person to check') do |i|
      @options.command_args.id = i
    end

    @parsers[parser_name].separator ''
  end

  def define_parser_first
    parser_name = 'first'

    @options.command_args       = OpenStruct.new
    @options.command_args.id    = nil
    @options.command_args.from  = nil
    @options.command_args.until = nil

    @parsers[parser_name] = OptionParser.new
    @parsers[parser_name].banner = MSG_COMMAND_NAME % parser_name
    @parsers[parser_name].separator 'Get hours worked by person.'

    @parsers[parser_name].on('-i', '--id ID', Integer, 'ID of the person to check') do |i|
      @options.command_args.id = i
    end

    @parsers[parser_name].on('-f', '--from DD.MM.YYYY', String,
               'First day to request info, Default: today') do |s|
      @options.command_args.from = Date.parse(s)
    end

    @parsers[parser_name].on('-t', '--till DD.MM.YYYY', String,
               'First day to request info, Default: FROM') do |s|
      @options.command_args.until = Date.parse(s)
    end

    @parsers[parser_name].separator ''
  end

  def define_parser_last
    parser_name = 'last'

    @options.command_args       = OpenStruct.new
    @options.command_args.id    = nil
    @options.command_args.from  = nil
    @options.command_args.until = nil

    @parsers[parser_name] = OptionParser.new
    @parsers[parser_name].banner = MSG_COMMAND_NAME % parser_name
    @parsers[parser_name].separator 'List all last entries of the person'

    @parsers[parser_name].on('-i', '--id ID', Integer, 'ID of the person to check') do |a|
      @options.command_args.id = i
    end

    @parsers[parser_name].on('-f', '--from DD.MM.YYYY', String,
               'First day to request info, Default: today') do |s|
      @options.command_args.from = Date.parse(s)
    end

    @parsers[parser_name].on('-t', '--till DD.MM.YYYY', String,
               'First day to request info, Default: FROM') do |s|
      @options.command_args.until = Date.parse(s)
    end

    @parsers[parser_name].separator ''
  end

  def define_parser_save
    parser_name = 'save'

    @options.command_args       = nil

    @parsers[parser_name] = OptionParser.new
    @parsers[parser_name].banner = MSG_COMMAND_NAME % parser_name
    @parsers[parser_name].separator 'Save entered global options for future use'

    @parsers[parser_name].separator ''
  end

  def setup_parsers
    @parsers = {}

    define_parser_global
    define_parser_hours
    define_parser_where
    define_parser_first
    define_parser_last
    define_parser_save
  rescue
    BBBHelper.p_error 'Error in the options parser configuration.'
  end

  def load_config
    File.open(CONFIG_FILE) do |f|
      config = YAML::load(f)

      @options.server   = config[:server]
      @options.login    = config[:login]
      @options.password = Base64.decode64(config[:password])

      BBBHelper.p_debug 'Configuration loaded from the file: ' + CONFIG_FILE
    end
  rescue
    BBBHelper.p_warning 'Unable to load configuration from the file: ' + CONFIG_FILE
  end

  def save_config
    config = {
      :server => @options.server,
      :login => @options.login,
      :password => Base64.encode64(@options.password)
    }

    Dir.mkdir(File.dirname(CONFIG_FILE)) unless Dir.exist?(File.dirname(CONFIG_FILE))
    File.open(CONFIG_FILE, mode = 'w') do |f|
      f.puts(config.to_yaml)
    end

    puts 'Configuration written to the file: ' + CONFIG_FILE
  rescue => e
    BBBHelper.p_error "Unable to write configuration to the file(#{CONFIG_FILE})"
    raise e
  end

  def parse(argv = ARGV)
    argv = @parsers[''].parse(argv)
    @options.command = argv.shift
    @parsers[command].parse(argv) if command
  rescue => e
    BBBHelper::p_error 'Unexpected error while processing arguments. Aborting…'
    raise e
  end

  def get_options
    @options.to_h
  end
end


begin
  options = BBBOptions.new

  options.parse(ARGV)

  BBBHelper.debug = options.debug
  BBBHelper.p_debug 'Parsed options: ' + options.get_options.to_s

  case options.command
  when 'doors'
    b = BBBrute.new(options)
    b.auth
    b.doors

  when 'save'
    options.save_config
  else
    BBBHelper.p_error 'Unrecognized command: ' + options.command.to_s
    exit 1
  end
rescue => exception
  STDERR.puts "E: #{exception}"
  raise exception
end
